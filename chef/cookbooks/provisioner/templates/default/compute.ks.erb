# Kickstart file automatically generated by anaconda.

install
url --url <%= @admin_web %>
key --skip
lang en_US.UTF-8
keyboard us
# crowbar
<% if node[:provisioner][:default_password_hash] -%>
rootpw --iscrypted <%= node[:provisioner][:default_password_hash] %>
<% else -%>
rootpw <%= node[:provisioner][:default_password] %>
<% end -%>
firewall --disabled
authconfig --enableshadow --enablemd5
selinux --disabled
timezone --utc Europe/London

%include /tmp/diskpart

text
reboot

%packages
@base
@core
<% if node[:platform_version].to_f >= 6 -%>
vim-enhanced
<% else -%>
@editors
@text-internet
<% end -%>
keyutils
trousers
fipscheck
device-mapper-multipath
OpenIPMI
OpenIPMI-tools
emacs-nox
openssh
curl.x86_64
ntp
tcpdump


%pre
#!/bin/bash

exec > /tmp/pre-install.log 2>&1
set -x -v

find_drive()
{
    serial_number=$@

    DRIVE_NAME=""

    file_prefixes="sd* hd*"
    for file_prefix in ${file_prefixes}
    do
        for drive_name in $(ls /sys/block|grep "^${file_prefix}")
        do
            removable=$(cat /sys/block/${drive_name}/removable)
            if [ "${removable}" -eq 1 ]
            then
                continue
            fi

            # Get the serial number of the drive
            # Note that we MUST do this using hdparm as this is the only
            # command that BusyBox supports to retrieve drive serial numbers
            serial_number_line=$(hdparm -I /dev/${drive_name} | grep "Serial Number:")
            test_serial_number=$(echo $serial_number_line|awk -F: '{print $2}')
            test_serial_number=$(sed -e 's/^[:space:]*[:space:]$//' <<<$test_serial_number)

            if [ "${test_serial_number}" = "${serial_number}" ]
            then
                DRIVE_NAME=${drive_name}
                break
            fi
        done

        if [ -n "${DRIVE_NAME}" ]
        then
            break
        fi
    done
}

get_install_drives()
{
    # Put together comma separated sorted list of the drives
    INSTALL_DRIVES=""
    first=1
    for sorted_drive in ${sorted_drives}
    do
        [ $first -ne 1 ] && INSTALL_DRIVES="${INSTALL_DRIVES},"
        INSTALL_DRIVES="${INSTALL_DRIVES}${sorted_drive}"

        first=0
    done
}

get_ignore_drives()
{
    sorted_drives="$@"

    get_ignore_drives_prefix sd ${sorted_drives}
    scsi_ignore_drives=${PREFIX_IGNORE_DRIVES}
    get_ignore_drives_prefix hd ${sorted_drives}
    sata_ignore_drives=${PREFIX_IGNORE_DRIVES}

    IGNORE_DRIVES="${scsi_ignore_drives}${sata_ignore_drives}"
    chop_length=$((${#IGNORE_DRIVES}-1))
    IGNORE_DRIVES=${IGNORE_DRIVES:0:${chop_length}}
}

get_ignore_drives_prefix()
{
    prefix=$1
    shift
    sorted_drives="$@"

    drive_letters="abcdefghijklmnopqrstuvwxyz"

    PREFIX_IGNORE_DRIVES=""
    letter_posn=0
    while [ ${letter_posn} -lt ${#drive_letters} ]
    do
        test_letter=${drive_letters:$letter_posn:1}
        letter_posn=$((letter_posn+1))

        for sorted_drive in ${sorted_drives}
        do
            if [ "${test_letter}" = "${sorted_drive:2:1}" ]
            then
              continue 2
            fi
        done

        PREFIX_IGNORE_DRIVES="${PREFIX_IGNORE_DRIVES}${prefix}${test_letter},"
    done
}

generate_partition_lines()
{
    num_drives="$#"
    echo "num_drives=${num_drives}"
    sorted_drives="$@"

<% if node[:platform_version].to_f >= 6 -%>
    fs_type="ext4"
<% else -%>
    fs_type="ext3"
<% end -%>
    disk_number=1
    boot_partitions=""
    swap_partitions=""
    for sorted_drive in ${sorted_drives}
    do
        boot_partition_name="raid.${disk_number}0"
        swap_partition_name="raid.${disk_number}1"

        echo "part ${boot_partition_name}    --size 100         --asprimary --ondrive=${sorted_drive}" >> /tmp/diskpart
        echo "part ${swap_partition_name}    --size 1   --grow  --asprimary --ondrive=${sorted_drive}" >> /tmp/diskpart

        boot_partitions="${boot_partitions}${boot_partition_name}"
        swap_partitions="${swap_partitions}${swap_partition_name}"
        if [ ${disk_number} -lt ${num_drives} ]
        then
            boot_partitions="${boot_partitions} "
            swap_partitions="${swap_partitions} "
        fi

        disk_number=$(($disk_number+1))
    done

    # Generate the raid lines
    echo "raid /boot --fstype ${fs_type} --device=md0 --level=RAID1 ${boot_partitions}" >> /tmp/diskpart
    echo "raid pv.01 --fstype ${fs_type} --device=md1 --level=RAID1 ${swap_partitions}" >> /tmp/diskpart
}

while : ; do
  sleep 10
  if [ -d /mnt/sysimage/root ]; then
    cp /tmp/pre-install.log /mnt/sysimage/root/
    break
  fi
done &

# Go get curl
cd /tmp
wget http://<%= @admin_node_ip %>:<%= @web_port %>/curl/curl
chmod ugo+x ./curl

# Get the authentication key
key_re='crowbar\.install\.key=([^ ]+)'
if [[ $(cat /proc/cmdline) =~ $key_re ]]; then
    export CROWBAR_KEY="${BASH_REMATCH[1]}"
else
    echo "Unable to find corwbar.install.key parameter: $(cat /proc/cmdline)"
    exit
fi

host_name=$(hostname)
curlargs=(--connect-timeout 60 -s -L -X GET --max-time 240 -u "$CROWBAR_KEY" --digest --anyauth)
drive_sns=$(./curl "${curlargs[@]}" "http://<%= @admin_node_ip %>:3000/crowbar/provisioner/1.0/get_installation_drives/default?name=${host_name}")

# Translate the list of serial numbers into a list of drives
drives=""
num_drives=0
for drive_sn in ${drive_sns}
do
    find_drive "${drive_sn}"

    [ $num_drives -ne 0 ] && drives="${drives}\n"
    drives="${drives}${DRIVE_NAME}"

    num_drives=$((num_drives+1))
done

# If none of the drives have a SN, then we are running on a VM.  In this case,
# we don't have internal or front drives, so just install on the first drive,
# preferring scsi drives
if [ -z "${drives}" ]
then
    drives=$(ls /dev/sd* | head -n 1)
    if [ -z "${drives}" ]
    then
        drives=$(ls /dev/hd* | head -n 1)
    fi
fi

sorted_drives=$(echo -e $drives|sort)

get_install_drives $sorted_drives
get_ignore_drives $sorted_drives

if [ $num_drives -gt 1 ]
then
    # RAID 1
    echo "bootloader --location=mbr --driveorder=${INSTALL_DRIVES} --append=\"rhgb quiet\"" > /tmp/diskpart
    echo "zerombr" >> /tmp/diskpart

<% if node[:platform_version].to_f >= 6 -%>
    echo "ignoredisk --only-use=${INSTALL_DRIVES}" >> /tmp/diskpart
    echo "clearpart --all --drives=${INSTALL_DRIVES}" >> /tmp/diskpart
    generate_partition_lines $sorted_drives
    echo "volgroup lv_admin --pesize=32768 pv.01" >> /tmp/diskpart
    echo "logvol / --fstype ext4 --name=lv_root --vgname=lv_admin --size=1 --grow" >> /tmp/diskpart
<% else -%>
    echo "ignoredisk --drives=${IGNORE_DRIVES}" >> /tmp/diskpart
    echo "clearpart --all --drives=${INSTALL_DRIVES}" >> /tmp/diskpart
    generate_partition_lines $sorted_drives
    echo "volgroup lv_admin --pesize=32768 pv.01" >> /tmp/diskpart
    echo "logvol / --fstype ext3 --name=lv_root --vgname=lv_admin --size=1 --grow" >> /tmp/diskpart
<% end -%>
    echo "logvol swap --fstype swap --name=lv_swap --vgname=lv_admin --recommended" >> /tmp/diskpart
else
    # No RAID
    echo "bootloader --location=mbr --driveorder=${INSTALL_DRIVES} --append=\"rhgb quiet\"" > /tmp/diskpart
    echo "zerombr" >> /tmp/diskpart

<% if node[:platform_version].to_f >= 6 -%>
    echo "ignoredisk --only-use=${INSTALL_DRIVES}" >> /tmp/diskpart
    echo "clearpart --all --drives=${INSTALL_DRIVES}" >> /tmp/diskpart
    echo "part /boot --fstype ext4 --size=100 --ondisk=${INSTALL_DRIVES}" >> /tmp/diskpart
    echo "part swap --recommended" >> /tmp/diskpart
    echo "part pv.6 --size=1 --grow --ondisk=${INSTALL_DRIVES}" >> /tmp/diskpart
    echo "volgroup lv_admin --pesize=32768 pv.6" >> /tmp/diskpart
    echo "logvol / --fstype ext4 --name=lv_root --vgname=lv_admin --size=1 --grow" >> /tmp/diskpart
<% else -%>
    echo "ignoredisk --drives=${IGNORE_DRIVES}" >> /tmp/diskpart
    echo "clearpart --all --drives=${INSTALL_DRIVES}" >> /tmp/diskpart
    echo "part /boot --fstype ext3 --size=100 --ondisk=${INSTALL_DRIVES}" >> /tmp/diskpart
    echo "part swap --recommended" >> /tmp/diskpart
    echo "part pv.6 --size=0 --grow --ondisk=${INSTALL_DRIVES}" >> /tmp/diskpart
    echo "volgroup lv_admin --pesize=32768 pv.6" >> /tmp/diskpart
    echo "logvol / --fstype ext3 --name=lv_root --vgname=lv_admin --size=1 --grow" >> /tmp/diskpart
<% end -%>
fi


%post

exec > /root/post-install.log 2>&1
set -x
export PS4='${BASH_SOURCE}@${LINENO}(${FUNCNAME[0]}): '
(cd /etc/yum.repos.d && rm *)
<% @repos.each do |repo,url| -%>
cat >/etc/yum.repos.d/crowbar-<%=repo%>.repo <<EOF
[crowbar-<%=repo%>]
name=Crowbar <%=repo%> Repo
<%=url%>
gpgcheck=0
EOF
<% end %>

HTTP_SERVER="<%= @admin_node_ip %>:<%= @web_port %>"
IP="<%= @admin_node_ip %>"
HOSTNAME=$(hostname -f)

key_re='crowbar\.install\.key=([^ ]+)'
if [[ $(cat /proc/cmdline) =~ $key_re ]]; then
    export CROWBAR_KEY="${BASH_REMATCH[1]}"
    echo "$CROWBAR_KEY" >/etc/crowbar.install.key
elif [[ -f /etc/crowbar.install.key ]]; then
    export CROWBAR_KEY="$(cat /etc/crowbar.install.key)"
fi

post_state() {
  local curlargs=(-o "/var/log/$1-$2.json" --connect-timeout 60 -s \
      -L -X POST --data-binary "{ \"name\": \"$1\", \"state\": \"$2\" }" \
      -H "Accept: application/json" -H "Content-Type: application/json" \
      --max-time 240)
  [[ $CROWBAR_KEY ]] && curlargs+=(-u "$CROWBAR_KEY" --digest --anyauth)
  curl "${curlargs[@]}" "http://$IP:3000/crowbar/crowbar/1.0/transition/default"
}

post_state $HOSTNAME "installing"

#"Blacklisting IPv6".
echo "blacklist ipv6" >>/etc/modprobe.d/blacklist-ipv6.conf
echo "options ipv6 disable=1" >>/etc/modprobe.d/blacklist-ipv6.conf

rsyslog_dir="/etc/rsyslog.d"
mkdir -p "$rsyslog_dir"
echo '$IncludeConfig /etc/rsyslog.d/*.conf' >>/etc/rsyslog.conf
if [ ! -f "$rsyslog_dir/10-crowbar-client.conf" ]; then
    echo "*.* @@${IP}" > "$rsyslog_dir/10-crowbar-client.conf"
    if ! curl -f -s -o "$rsyslog_dir/00-crowbar-debug.conf" \
        <%= @admin_web %>/rsyslog.d/00-crowbar-debug.conf
    then
        rm -f "$rsyslog_dir/00-crowbar-debug.conf"
    fi
fi

mkdir -p /root/.ssh
chmod 700 /root/.ssh
if ! curl -s -o /root/.ssh/authorized_keys.wget \
    http://$HTTP_SERVER/authorized_keys; then
    rm -f /root/.ssh/authorized_keys.wget
else
    chmod 644 /root/.ssh/authorized_keys
    cat /root/.ssh/authorized_keys.wget >>/root/.ssh/authorized_keys
    rm -f /root/.ssh/authorized_keys.wget
fi

curl -s -o /etc/init.d/crowbar_join.sh <%= @crowbar_join %>
chmod +x /etc/init.d/crowbar_join.sh
ln -s /etc/init.d/crowbar_join.sh /etc/rc3.d/S80crowbar
ln -s /etc/init.d/crowbar_join.sh /etc/rc5.d/S80crowbar
ln -s /etc/init.d/crowbar_join.sh /etc/rc2.d/S80crowbar

# boot to runlevel 3 by default
sed -i -e '/initdefault/ s/5/3/' /etc/inittab

sleep 30

post_state $HOSTNAME "installed"

# Wait for DHCP to update - this is mainly for virtual environments or really large deploys
sleep 30
sync
